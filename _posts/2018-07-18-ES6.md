# SOME NEW FEATURES IN ES6

-----

### `const` and `let` (instead of `var`)

* `const`: immutable
* `let`: mutable
* both are blocked-scope (only available within its scope)

### Arrow functions

```
// ES5
function foo(bar) {
  return 'hello';
}

// ES6
const foo = bar => 'hello';

```
* Looks cleaner and more readable
* Can be used with `map`, `filter`, `reduce` neatly

### Template Literals

```
// ES5
function foo(bar, barr){
  return 'Hello' + bar + '! How about ' + barr + '?';
}

// ES6
const foo = (bar, barr) => 'Hello ${bar}! How about ${barr}';

```

### Default parameters

```
const foo = (bar, barr = 0) => {
  return 'Hello ${bar}! You ate ${barr} apples today!'
} 
```
The above function won't return undefined even if we forget to pass in the value for `barr`

### Array and object destructuring

```
// ES5
var profile = {
  firstName: 'bar', 
  lastName: 'foo', 
  age: 28
}

var firstName = profile.firstName;
var lastName = profile.lastName;
var age = profile.age;

// ES6
const profile = {
  firstName: 'bar', 
  lastName: 'foo', 
  age: 28
}

let {firstName, lastName, age} = profile;

```
* As we can see, we don't have to individually assign variables
* The same rule applies for arrays
* If the assigned variables have different names to the object keys, then we can do:
```
let {firstName, lastName: surname, age} = profile;
```

### Import and export

* ES6 allows for the use of `import` and `export` to enable us to create separate and reusable components

### Promises

* ES6 allows for the use of Promises
* It's a different way of writing asynchronous code (besides using callbacks, or `async` `await`)

### Rest Paramter and Spead Parameter

* **Rest parameter:**
	* Allows us to represent an indefinite number of arguments as an array
	* E.g.
	
	```
	const sum = (...args) => {
	  return args.reduce((prev, curr) => {return prev + curr}); 
	}
	
	console.log(sum(1,2,3));
	// 6
	```
	
* **Spread Operator:**


